----------------------------------------------------------------
--                                                            --
--        GIVEAWAYS COMPLETE DATABASE SETUP                   --
--        Execute this file to set up all giveaways tables    --
--                                                            --
----------------------------------------------------------------
-- Prerequisites: seed.sql already executed
-- This combines both migration files into one
----------------------------------------------------------------

-- 1. GIVEAWAYS TABLE
CREATE TABLE IF NOT EXISTS giveaways (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  deleted_at TIMESTAMPTZ,
  
  -- Creator info
  user_id UUID REFERENCES users(id) ON DELETE CASCADE NOT NULL,
  
  -- Giveaway details
  title TEXT NOT NULL,
  slug TEXT NOT NULL,
  description TEXT,
  thumbnail_url TEXT,
  
  -- Duration & status
  start_date TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  end_date TIMESTAMPTZ NOT NULL,
  status TEXT DEFAULT 'active' NOT NULL,
  
  -- Winner info
  winner_id UUID REFERENCES users(id) ON DELETE SET NULL,
  winner_guest_id UUID,
  winner_selected_at TIMESTAMPTZ,
  
  -- Settings
  max_participants INTEGER,
  allow_guests BOOLEAN DEFAULT TRUE NOT NULL,
  require_email BOOLEAN DEFAULT FALSE NOT NULL,
  
  -- Moderation
  is_featured BOOLEAN DEFAULT FALSE NOT NULL,
  is_banned BOOLEAN DEFAULT FALSE NOT NULL,
  banned_until TIMESTAMPTZ,
  
  -- Constraints
  UNIQUE(user_id, slug),
  CHECK (end_date > start_date),
  CHECK (status IN ('active', 'running', 'ended', 'cancelled'))
);

COMMENT ON COLUMN giveaways.updated_at IS 'on_updated_at';
COMMENT ON COLUMN giveaways.status IS 'active (scheduled), running (live), ended, cancelled';

-- Indexes
CREATE INDEX IF NOT EXISTS giveaways_user_id_idx ON giveaways(user_id) WHERE deleted_at IS NULL;
CREATE INDEX IF NOT EXISTS giveaways_status_end_date_idx ON giveaways(status, end_date) WHERE deleted_at IS NULL;
CREATE INDEX IF NOT EXISTS giveaways_slug_idx ON giveaways(slug) WHERE deleted_at IS NULL;
CREATE INDEX IF NOT EXISTS giveaways_featured_idx ON giveaways(is_featured, created_at DESC) WHERE is_featured = TRUE AND deleted_at IS NULL;
CREATE INDEX IF NOT EXISTS giveaways_active_idx ON giveaways(status, start_date, end_date) WHERE status IN ('active', 'running') AND is_banned = FALSE AND deleted_at IS NULL;

-- RLS Policies
ALTER TABLE giveaways ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Public can view active giveaways" ON giveaways;
CREATE POLICY "Public can view active giveaways"
ON giveaways FOR SELECT
TO authenticated, anon
USING (
  status IN ('active', 'running') 
  AND is_banned = FALSE 
  AND deleted_at IS NULL
);

DROP POLICY IF EXISTS "Users can view their own giveaways" ON giveaways;
CREATE POLICY "Users can view their own giveaways"
ON giveaways FOR SELECT
TO authenticated
USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "User can insert their own giveaways" ON giveaways;
CREATE POLICY "User can insert their own giveaways"
ON giveaways FOR INSERT
TO authenticated
WITH CHECK (
  auth.uid() = user_id
  AND EXISTS (
    SELECT 1 FROM users 
    WHERE id = auth.uid() 
    AND role IN ('user', 'admin', 'superadmin')
  )
);

DROP POLICY IF EXISTS "User can update their own giveaways" ON giveaways;
CREATE POLICY "User can update their own giveaways"
ON giveaways FOR UPDATE
TO authenticated
USING (auth.uid() = user_id)
WITH CHECK (auth.uid() = user_id);

DROP POLICY IF EXISTS "User can delete their own giveaways" ON giveaways;
CREATE POLICY "User can delete their own giveaways"
ON giveaways FOR DELETE
TO authenticated
USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Admin can view all giveaways" ON giveaways;
CREATE POLICY "Admin can view all giveaways"
ON giveaways FOR SELECT
TO authenticated
USING (
  EXISTS (
    SELECT 1 FROM users 
    WHERE id = auth.uid() 
    AND role IN ('admin', 'superadmin')
  )
);

DROP POLICY IF EXISTS "Admin can manage all giveaways" ON giveaways;
CREATE POLICY "Admin can manage all giveaways"
ON giveaways FOR ALL
TO authenticated
USING (
  EXISTS (
    SELECT 1 FROM users 
    WHERE id = auth.uid() 
    AND role IN ('admin', 'superadmin')
  )
)
WITH CHECK (
  EXISTS (
    SELECT 1 FROM users 
    WHERE id = auth.uid() 
    AND role IN ('admin', 'superadmin')
  )
);

-- Trigger for updated_at
CREATE TRIGGER on_updated_at BEFORE UPDATE ON giveaways
  FOR EACH ROW EXECUTE PROCEDURE moddatetime (updated_at);

----------------------------------------------------------------

-- 2. GIVEAWAY PARTICIPANTS TABLE
CREATE TABLE IF NOT EXISTS giveaway_participants (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  
  -- Giveaway reference
  giveaway_id BIGINT REFERENCES giveaways(id) ON DELETE CASCADE NOT NULL,
  
  -- Participant info
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  guest_id UUID,
  
  -- Guest details
  guest_email TEXT,
  guest_name TEXT,
  telegram_handle TEXT,
  
  -- Tracking
  ip_address INET NOT NULL,
  user_agent TEXT,
  fingerprint TEXT,
  
  -- Turnstile verification
  turnstile_token TEXT,
  turnstile_verified BOOLEAN DEFAULT FALSE,
  verification_ip INET,
  
  -- Weight for random selection
  weight INTEGER DEFAULT 1 NOT NULL,
  
  -- Prevent duplicates
  UNIQUE(giveaway_id, user_id),
  UNIQUE(giveaway_id, guest_id),
  UNIQUE(giveaway_id, telegram_handle),
  CHECK (
    (user_id IS NOT NULL AND guest_id IS NULL) OR
    (user_id IS NULL AND guest_id IS NOT NULL)
  )
);

-- Indexes
CREATE INDEX IF NOT EXISTS giveaway_participants_giveaway_id_idx ON giveaway_participants(giveaway_id);
CREATE INDEX IF NOT EXISTS giveaway_participants_user_id_idx ON giveaway_participants(user_id) WHERE user_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS giveaway_participants_guest_id_idx ON giveaway_participants(guest_id) WHERE guest_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS giveaway_participants_ip_address_idx ON giveaway_participants(giveaway_id, ip_address);
CREATE INDEX IF NOT EXISTS giveaway_participants_fingerprint_idx ON giveaway_participants(giveaway_id, fingerprint) WHERE fingerprint IS NOT NULL;
CREATE INDEX IF NOT EXISTS giveaway_participants_created_at_idx ON giveaway_participants(created_at DESC);
CREATE INDEX IF NOT EXISTS giveaway_participants_telegram_idx ON giveaway_participants(giveaway_id, telegram_handle) WHERE telegram_handle IS NOT NULL;
CREATE INDEX IF NOT EXISTS giveaway_participants_weight_idx ON giveaway_participants(giveaway_id, weight, id);

-- RLS Policies
ALTER TABLE giveaway_participants ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Public can view participants count" ON giveaway_participants;
CREATE POLICY "Public can view participants count"
ON giveaway_participants FOR SELECT
TO authenticated, anon
USING (TRUE);

DROP POLICY IF EXISTS "Users can view their own participation" ON giveaway_participants;
CREATE POLICY "Users can view their own participation"
ON giveaway_participants FOR SELECT
TO authenticated
USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Anyone can insert participation" ON giveaway_participants;
CREATE POLICY "Anyone can insert participation"
ON giveaway_participants FOR INSERT
TO authenticated, anon
WITH CHECK (TRUE);

DROP POLICY IF EXISTS "Admin can manage participants" ON giveaway_participants;
CREATE POLICY "Admin can manage participants"
ON giveaway_participants FOR ALL
TO authenticated
USING (
  EXISTS (
    SELECT 1 FROM users 
    WHERE id = auth.uid() 
    AND role IN ('admin', 'superadmin')
  )
);

----------------------------------------------------------------

-- 3. RATE LIMITING TABLE
CREATE TABLE IF NOT EXISTS rate_limits (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  
  -- Identifier
  identifier TEXT NOT NULL,
  action TEXT NOT NULL,
  
  -- Rate limit tracking
  attempts INTEGER DEFAULT 1 NOT NULL,
  window_start TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  
  -- Blocking
  is_blocked BOOLEAN DEFAULT FALSE NOT NULL,
  blocked_until TIMESTAMPTZ,
  
  UNIQUE(identifier, action)
);

-- Indexes
CREATE INDEX IF NOT EXISTS rate_limits_identifier_action_idx ON rate_limits(identifier, action);
CREATE INDEX IF NOT EXISTS rate_limits_window_start_idx ON rate_limits(window_start);
CREATE INDEX IF NOT EXISTS rate_limits_blocked_idx ON rate_limits(is_blocked, blocked_until) WHERE is_blocked = TRUE;

-- RLS Policies
ALTER TABLE rate_limits ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Admin can view rate limits" ON rate_limits;
CREATE POLICY "Admin can view rate limits"
ON rate_limits FOR SELECT
TO authenticated
USING (
  EXISTS (
    SELECT 1 FROM users 
    WHERE id = auth.uid() 
    AND role IN ('admin', 'superadmin')
  )
);

DROP POLICY IF EXISTS "Admin can manage rate limits" ON rate_limits;
CREATE POLICY "Admin can manage rate limits"
ON rate_limits FOR ALL
TO authenticated
USING (
  EXISTS (
    SELECT 1 FROM users 
    WHERE id = auth.uid() 
    AND role IN ('admin', 'superadmin')
  )
);

----------------------------------------------------------------

-- 4. ABUSE REPORTS TABLE
CREATE TABLE IF NOT EXISTS abuse_reports (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  
  -- What was reported
  resource_type TEXT NOT NULL,
  resource_id BIGINT NOT NULL,
  
  -- Who reported
  reporter_user_id UUID REFERENCES users(id) ON DELETE SET NULL,
  reporter_ip INET,
  
  -- Report details
  reason TEXT NOT NULL,
  description TEXT,
  
  -- Status
  status TEXT DEFAULT 'pending' NOT NULL,
  reviewed_by UUID REFERENCES users(id) ON DELETE SET NULL,
  reviewed_at TIMESTAMPTZ,
  
  CHECK (status IN ('pending', 'reviewed', 'actioned', 'dismissed'))
);

-- Indexes
CREATE INDEX IF NOT EXISTS abuse_reports_resource_idx ON abuse_reports(resource_type, resource_id);
CREATE INDEX IF NOT EXISTS abuse_reports_status_idx ON abuse_reports(status, created_at DESC) WHERE status = 'pending';
CREATE INDEX IF NOT EXISTS abuse_reports_reporter_idx ON abuse_reports(reporter_user_id) WHERE reporter_user_id IS NOT NULL;

-- RLS Policies
ALTER TABLE abuse_reports ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can create abuse reports" ON abuse_reports;
CREATE POLICY "Users can create abuse reports"
ON abuse_reports FOR INSERT
TO authenticated, anon
WITH CHECK (TRUE);

DROP POLICY IF EXISTS "Users can view their own reports" ON abuse_reports;
CREATE POLICY "Users can view their own reports"
ON abuse_reports FOR SELECT
TO authenticated
USING (auth.uid() = reporter_user_id);

DROP POLICY IF EXISTS "Admin can view all reports" ON abuse_reports;
CREATE POLICY "Admin can view all reports"
ON abuse_reports FOR SELECT
TO authenticated
USING (
  EXISTS (
    SELECT 1 FROM users 
    WHERE id = auth.uid() 
    AND role IN ('admin', 'superadmin')
  )
);

DROP POLICY IF EXISTS "Admin can manage reports" ON abuse_reports;
CREATE POLICY "Admin can manage reports"
ON abuse_reports FOR UPDATE
TO authenticated
USING (
  EXISTS (
    SELECT 1 FROM users 
    WHERE id = auth.uid() 
    AND role IN ('admin', 'superadmin')
  )
);

----------------------------------------------------------------

-- 5. VERIFICATION ATTEMPTS TABLE
CREATE TABLE IF NOT EXISTS verification_attempts (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  
  -- Tracking
  ip_address INET NOT NULL,
  fingerprint TEXT,
  action TEXT NOT NULL,
  
  -- Turnstile
  turnstile_token TEXT,
  turnstile_success BOOLEAN DEFAULT FALSE,
  
  -- Result
  success BOOLEAN DEFAULT FALSE,
  error_message TEXT,
  
  -- Metadata
  user_agent TEXT,
  giveaway_id BIGINT REFERENCES giveaways(id) ON DELETE CASCADE
);

-- Indexes
CREATE INDEX IF NOT EXISTS verification_attempts_ip_idx ON verification_attempts(ip_address, created_at DESC);
CREATE INDEX IF NOT EXISTS verification_attempts_fingerprint_idx ON verification_attempts(fingerprint, created_at DESC) WHERE fingerprint IS NOT NULL;
CREATE INDEX IF NOT EXISTS verification_attempts_giveaway_idx ON verification_attempts(giveaway_id, created_at DESC) WHERE giveaway_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS verification_attempts_success_idx ON verification_attempts(success, created_at DESC);

-- RLS Policies
ALTER TABLE verification_attempts ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Admin can view verification attempts" ON verification_attempts;
CREATE POLICY "Admin can view verification attempts"
ON verification_attempts FOR SELECT
TO authenticated
USING (
  EXISTS (
    SELECT 1 FROM users 
    WHERE id = auth.uid() 
    AND role IN ('admin', 'superadmin')
  )
);

DROP POLICY IF EXISTS "Admin can manage verification attempts" ON verification_attempts;
CREATE POLICY "Admin can manage verification attempts"
ON verification_attempts FOR ALL
TO authenticated
USING (
  EXISTS (
    SELECT 1 FROM users 
    WHERE id = auth.uid() 
    AND role IN ('admin', 'superadmin')
  )
);

----------------------------------------------------------------
--                    DATABASE FUNCTIONS                      --
----------------------------------------------------------------

-- Performance note: All functions use SECURITY DEFINER with explicit search_path
-- to prevent search_path injection attacks and ensure consistent behavior

-- 1. RATE LIMITING FUNCTION
CREATE OR REPLACE FUNCTION check_rate_limit(
  p_identifier TEXT,
  p_action TEXT,
  p_max_attempts INTEGER DEFAULT 10,
  p_window_minutes INTEGER DEFAULT 60
)
RETURNS BOOLEAN
SECURITY DEFINER SET search_path = public
AS $$
DECLARE
  v_record RECORD;
  v_window_start TIMESTAMPTZ;
BEGIN
  v_window_start := NOW() - (p_window_minutes || ' minutes')::INTERVAL;
  
  -- Get or create rate limit record
  SELECT * INTO v_record
  FROM rate_limits
  WHERE identifier = p_identifier AND action = p_action
  FOR UPDATE;
  
  IF NOT FOUND THEN
    -- Create new record
    INSERT INTO rate_limits (identifier, action, attempts, window_start)
    VALUES (p_identifier, p_action, 1, NOW());
    RETURN TRUE;
  END IF;
  
  -- Check if blocked
  IF v_record.is_blocked AND v_record.blocked_until > NOW() THEN
    RETURN FALSE;
  END IF;
  
  -- Reset if outside window
  IF v_record.window_start < v_window_start THEN
    UPDATE rate_limits
    SET attempts = 1, window_start = NOW(), is_blocked = FALSE, blocked_until = NULL
    WHERE identifier = p_identifier AND action = p_action;
    RETURN TRUE;
  END IF;
  
  -- Check if limit exceeded
  IF v_record.attempts >= p_max_attempts THEN
    UPDATE rate_limits
    SET is_blocked = TRUE, blocked_until = NOW() + INTERVAL '1 hour'
    WHERE identifier = p_identifier AND action = p_action;
    RETURN FALSE;
  END IF;
  
  -- Increment attempts
  UPDATE rate_limits
  SET attempts = attempts + 1
  WHERE identifier = p_identifier AND action = p_action;
  
  RETURN TRUE;
END;
$$ LANGUAGE plpgsql;

----------------------------------------------------------------

-- 2. JOIN GIVEAWAY SECURE FUNCTION
CREATE OR REPLACE FUNCTION join_giveaway_secure(
  p_giveaway_id BIGINT,
  p_telegram_handle TEXT,
  p_guest_name TEXT,
  p_ip_address INET,
  p_fingerprint TEXT,
  p_turnstile_token TEXT,
  p_user_agent TEXT DEFAULT NULL
)
RETURNS JSON
SECURITY DEFINER SET search_path = public
AS $$
DECLARE
  v_giveaway RECORD;
  v_identifier TEXT;
  v_participant_count INTEGER;
  v_duplicate_count INTEGER;
  v_guest_id UUID;
BEGIN
  -- Validate inputs
  IF p_telegram_handle IS NULL OR p_telegram_handle = '' THEN
    RETURN json_build_object('success', FALSE, 'error', 'Telegram handle is required');
  END IF;
  
  IF p_guest_name IS NULL OR p_guest_name = '' THEN
    RETURN json_build_object('success', FALSE, 'error', 'Name is required');
  END IF;
  
  -- Normalize telegram handle
  p_telegram_handle := LOWER(TRIM(BOTH FROM p_telegram_handle));
  IF NOT p_telegram_handle ~ '^@?[a-z0-9_]{5,32}$' THEN
    RETURN json_build_object('success', FALSE, 'error', 'Invalid Telegram handle format. Use @username (5-32 characters)');
  END IF;
  
  -- Ensure @ prefix
  IF NOT p_telegram_handle LIKE '@%' THEN
    p_telegram_handle := '@' || p_telegram_handle;
  END IF;
  
  -- Rate limiting by IP (check first for performance)
  v_identifier := p_ip_address::TEXT;
  IF NOT check_rate_limit(v_identifier, 'giveaway_join', 10, 60) THEN
    RETURN json_build_object('success', FALSE, 'error', 'Too many attempts. Please wait before trying again.');
  END IF;
  
  -- Get giveaway details with lock
  SELECT * INTO v_giveaway
  FROM giveaways
  WHERE id = p_giveaway_id
  AND deleted_at IS NULL
  FOR UPDATE;
  
  -- Validation checks
  IF NOT FOUND THEN
    RETURN json_build_object('success', FALSE, 'error', 'Giveaway not found');
  END IF;
  
  IF v_giveaway.status NOT IN ('active', 'running') THEN
    RETURN json_build_object('success', FALSE, 'error', 'Giveaway is not active');
  END IF;
  
  IF v_giveaway.is_banned THEN
    RETURN json_build_object('success', FALSE, 'error', 'This giveaway has been suspended');
  END IF;
  
  IF v_giveaway.end_date < NOW() THEN
    RETURN json_build_object('success', FALSE, 'error', 'Giveaway has ended');
  END IF;
  
  -- Check max participants
  IF v_giveaway.max_participants IS NOT NULL THEN
    SELECT COUNT(*) INTO v_participant_count
    FROM giveaway_participants
    WHERE giveaway_id = p_giveaway_id;
    
    IF v_participant_count >= v_giveaway.max_participants THEN
      RETURN json_build_object('success', FALSE, 'error', 'Giveaway is full. Maximum participants reached.');
    END IF;
  END IF;
  
  -- Check for duplicates using single query (optimized)
  SELECT COUNT(*) INTO v_duplicate_count
  FROM giveaway_participants
  WHERE giveaway_id = p_giveaway_id
  AND (
    telegram_handle = p_telegram_handle
    OR (fingerprint = p_fingerprint AND fingerprint IS NOT NULL)
    OR ip_address = p_ip_address
  );
  
  IF v_duplicate_count > 0 THEN
    -- Check specific duplicate type for better error message
    IF EXISTS (
      SELECT 1 FROM giveaway_participants
      WHERE giveaway_id = p_giveaway_id AND telegram_handle = p_telegram_handle
    ) THEN
      RETURN json_build_object('success', FALSE, 'error', 'This Telegram handle has already participated');
    ELSIF EXISTS (
      SELECT 1 FROM giveaway_participants
      WHERE giveaway_id = p_giveaway_id AND fingerprint = p_fingerprint AND fingerprint IS NOT NULL
    ) THEN
      RETURN json_build_object('success', FALSE, 'error', 'You have already participated from this device');
    ELSE
      RETURN json_build_object('success', FALSE, 'error', 'Someone has already participated from your connection');
    END IF;
  END IF;
  
  -- Generate guest ID
  v_guest_id := gen_random_uuid();
  
  -- Insert participant
  INSERT INTO giveaway_participants (
    giveaway_id, guest_id, guest_name, telegram_handle,
    ip_address, user_agent, fingerprint, weight,
    turnstile_token, turnstile_verified, verification_ip
  ) VALUES (
    p_giveaway_id, v_guest_id, p_guest_name, p_telegram_handle,
    p_ip_address, p_user_agent, p_fingerprint, 1,
    p_turnstile_token, TRUE, p_ip_address
  );
  
  -- Log verification attempt (async, don't block on failure)
  BEGIN
    INSERT INTO verification_attempts (
      ip_address, fingerprint, action, turnstile_token,
      turnstile_success, success, giveaway_id, user_agent
    ) VALUES (
      p_ip_address, p_fingerprint, 'join_giveaway', p_turnstile_token,
      TRUE, TRUE, p_giveaway_id, p_user_agent
    );
  EXCEPTION WHEN OTHERS THEN
    -- Ignore logging errors
    NULL;
  END;
  
  RETURN json_build_object(
    'success', TRUE, 
    'message', 'Successfully joined the giveaway!',
    'participant_id', v_guest_id
  );
  
EXCEPTION
  WHEN unique_violation THEN
    -- Log failed attempt
    BEGIN
      INSERT INTO verification_attempts (
        ip_address, fingerprint, action, success, error_message, giveaway_id
      ) VALUES (
        p_ip_address, p_fingerprint, 'join_giveaway', FALSE, 'Already participated', p_giveaway_id
      );
    EXCEPTION WHEN OTHERS THEN
      NULL;
    END;
    RETURN json_build_object('success', FALSE, 'error', 'You have already participated in this giveaway');
  WHEN OTHERS THEN
    -- Log error
    BEGIN
      INSERT INTO verification_attempts (
        ip_address, fingerprint, action, success, error_message, giveaway_id
      ) VALUES (
        p_ip_address, p_fingerprint, 'join_giveaway', FALSE, SQLERRM, p_giveaway_id
      );
    EXCEPTION WHEN OTHERS THEN
      NULL;
    END;
    RETURN json_build_object('success', FALSE, 'error', 'An error occurred. Please try again.');
END;
$$ LANGUAGE plpgsql;

----------------------------------------------------------------

-- 3. CHECK PARTICIPATION FUNCTION
CREATE OR REPLACE FUNCTION check_participation(
  p_giveaway_id BIGINT,
  p_telegram_handle TEXT DEFAULT NULL,
  p_fingerprint TEXT DEFAULT NULL,
  p_ip_address INET DEFAULT NULL
)
RETURNS JSON
SECURITY DEFINER SET search_path = public
AS $$
DECLARE
  v_participated BOOLEAN := FALSE;
BEGIN
  -- Normalize telegram handle
  IF p_telegram_handle IS NOT NULL THEN
    p_telegram_handle := LOWER(TRIM(BOTH FROM p_telegram_handle));
    IF NOT p_telegram_handle LIKE '@%' THEN
      p_telegram_handle := '@' || p_telegram_handle;
    END IF;
  END IF;
  
  -- Check by telegram handle (most reliable)
  IF p_telegram_handle IS NOT NULL THEN
    SELECT EXISTS(
      SELECT 1 FROM giveaway_participants
      WHERE giveaway_id = p_giveaway_id 
      AND telegram_handle = p_telegram_handle
    ) INTO v_participated;
    
    IF v_participated THEN
      RETURN json_build_object(
        'participated', TRUE, 
        'method', 'telegram',
        'message', 'You have already participated with this Telegram handle'
      );
    END IF;
  END IF;
  
  -- Check by fingerprint
  IF p_fingerprint IS NOT NULL THEN
    SELECT EXISTS(
      SELECT 1 FROM giveaway_participants
      WHERE giveaway_id = p_giveaway_id 
      AND fingerprint = p_fingerprint
    ) INTO v_participated;
    
    IF v_participated THEN
      RETURN json_build_object(
        'participated', TRUE, 
        'method', 'device',
        'message', 'You have already participated from this device'
      );
    END IF;
  END IF;
  
  -- Check by IP
  IF p_ip_address IS NOT NULL THEN
    SELECT EXISTS(
      SELECT 1 FROM giveaway_participants
      WHERE giveaway_id = p_giveaway_id 
      AND ip_address = p_ip_address
    ) INTO v_participated;
    
    IF v_participated THEN
      RETURN json_build_object(
        'participated', TRUE, 
        'method', 'ip',
        'message', 'Someone has already participated from your connection'
      );
    END IF;
  END IF;
  
  RETURN json_build_object('participated', FALSE);
END;
$$ LANGUAGE plpgsql;

----------------------------------------------------------------

-- 4. SELECT WINNER FUNCTION
CREATE OR REPLACE FUNCTION select_giveaway_winner(p_giveaway_id BIGINT)
RETURNS JSON
SECURITY DEFINER SET search_path = public
AS $$
DECLARE
  v_giveaway RECORD;
  v_winner RECORD;
  v_total_weight BIGINT;
  v_random_weight BIGINT;
  v_cumulative_weight BIGINT := 0;
BEGIN
  -- Get giveaway
  SELECT * INTO v_giveaway
  FROM giveaways
  WHERE id = p_giveaway_id
  FOR UPDATE;
  
  IF NOT FOUND THEN
    RETURN json_build_object('success', FALSE, 'error', 'Giveaway not found');
  END IF;
  
  IF v_giveaway.winner_id IS NOT NULL OR v_giveaway.winner_guest_id IS NOT NULL THEN
    RETURN json_build_object('success', FALSE, 'error', 'Winner already selected');
  END IF;
  
  -- Calculate total weight
  SELECT SUM(weight) INTO v_total_weight
  FROM giveaway_participants
  WHERE giveaway_id = p_giveaway_id;
  
  IF v_total_weight IS NULL OR v_total_weight = 0 THEN
    RETURN json_build_object('success', FALSE, 'error', 'No participants');
  END IF;
  
  -- Generate random number
  v_random_weight := floor(random() * v_total_weight) + 1;
  
  -- Select winner using weighted random
  FOR v_winner IN
    SELECT *, weight
    FROM giveaway_participants
    WHERE giveaway_id = p_giveaway_id
    ORDER BY id
  LOOP
    v_cumulative_weight := v_cumulative_weight + v_winner.weight;
    
    IF v_cumulative_weight >= v_random_weight THEN
      -- Update giveaway with winner
      UPDATE giveaways
      SET 
        winner_id = v_winner.user_id,
        winner_guest_id = v_winner.guest_id,
        winner_selected_at = NOW(),
        status = 'ended'
      WHERE id = p_giveaway_id;
      
      RETURN json_build_object(
        'success', TRUE,
        'winner_id', v_winner.user_id,
        'winner_guest_id', v_winner.guest_id,
        'winner_email', v_winner.guest_email,
        'winner_name', v_winner.guest_name
      );
    END IF;
  END LOOP;
  
  RETURN json_build_object('success', FALSE, 'error', 'Failed to select winner');
END;
$$ LANGUAGE plpgsql;

----------------------------------------------------------------

-- 5. AUTO-END EXPIRED GIVEAWAYS
CREATE OR REPLACE FUNCTION auto_end_expired_giveaways()
RETURNS VOID
SECURITY DEFINER SET search_path = public
AS $$
BEGIN
  UPDATE giveaways
  SET status = 'ended'
  WHERE status IN ('active', 'running')
  AND end_date < NOW()
  AND deleted_at IS NULL;
END;
$$ LANGUAGE plpgsql;

----------------------------------------------------------------

-- 6. CLEANUP RATE LIMITS
CREATE OR REPLACE FUNCTION cleanup_old_rate_limits()
RETURNS VOID
SECURITY DEFINER SET search_path = public
AS $$
BEGIN
  DELETE FROM rate_limits
  WHERE created_at < NOW() - INTERVAL '24 hours'
  AND is_blocked = FALSE;
  
  -- Unblock expired blocks
  UPDATE rate_limits
  SET is_blocked = FALSE, blocked_until = NULL
  WHERE is_blocked = TRUE
  AND blocked_until < NOW();
END;
$$ LANGUAGE plpgsql;

----------------------------------------------------------------

-- 7. CLEANUP VERIFICATION ATTEMPTS
CREATE OR REPLACE FUNCTION cleanup_old_verification_attempts()
RETURNS VOID
SECURITY DEFINER SET search_path = public
AS $$
BEGIN
  DELETE FROM verification_attempts
  WHERE created_at < NOW() - INTERVAL '7 days';
END;
$$ LANGUAGE plpgsql;

----------------------------------------------------------------

-- GRANT PERMISSIONS
GRANT EXECUTE ON FUNCTION join_giveaway_secure TO authenticated, anon;
GRANT EXECUTE ON FUNCTION check_participation TO authenticated, anon;
GRANT EXECUTE ON FUNCTION select_giveaway_winner TO authenticated;
GRANT EXECUTE ON FUNCTION auto_end_expired_giveaways TO authenticated;
GRANT EXECUTE ON FUNCTION cleanup_old_rate_limits TO authenticated;
GRANT EXECUTE ON FUNCTION cleanup_old_verification_attempts TO authenticated;

----------------------------------------------------------------
--                 PERFORMANCE OPTIMIZATIONS                  --
----------------------------------------------------------------

-- Analyze tables for query planner statistics
ANALYZE giveaways;
ANALYZE giveaway_participants;
ANALYZE rate_limits;
ANALYZE abuse_reports;
ANALYZE verification_attempts;

-- Add table comments for documentation
COMMENT ON TABLE giveaways IS 'Stores giveaway campaigns with moderation and winner selection';
COMMENT ON TABLE giveaway_participants IS 'Tracks participants in giveaways with fraud prevention';
COMMENT ON TABLE rate_limits IS 'Rate limiting for API endpoints and actions';
COMMENT ON TABLE abuse_reports IS 'User-submitted abuse reports for moderation';
COMMENT ON TABLE verification_attempts IS 'Audit log for Turnstile verification attempts';

-- Add column comments for important fields
COMMENT ON COLUMN giveaways.slug IS 'URL-friendly identifier, unique per user';
COMMENT ON COLUMN giveaways.status IS 'active=scheduled, running=live, ended=completed, cancelled=stopped';
COMMENT ON COLUMN giveaway_participants.weight IS 'Weight for weighted random selection (default 1)';
COMMENT ON COLUMN giveaway_participants.fingerprint IS 'Browser fingerprint for duplicate detection';
COMMENT ON COLUMN rate_limits.window_start IS 'Start of current rate limit window';
COMMENT ON COLUMN verification_attempts.turnstile_success IS 'Whether Cloudflare Turnstile verification passed';

----------------------------------------------------------------
--                    SETUP COMPLETE                          --
----------------------------------------------------------------

-- Verify tables created
SELECT 'Tables created:' as status;
SELECT table_name FROM information_schema.tables 
WHERE table_schema = 'public' 
AND table_name IN ('giveaways', 'giveaway_participants', 'rate_limits', 'abuse_reports', 'verification_attempts')
ORDER BY table_name;

-- Verify functions created
SELECT 'Functions created:' as status;
SELECT routine_name FROM information_schema.routines 
WHERE routine_schema = 'public' 
AND routine_name LIKE '%giveaway%' OR routine_name LIKE '%rate_limit%' OR routine_name LIKE '%verification%'
ORDER BY routine_name;

SELECT 'âœ… Giveaways database setup complete!' as status;
