----------------------------------------------------------------
--                                                            --
--                    GIVEAWAYS FEATURE                       --
--                                                            --
----------------------------------------------------------------

-- 1. Giveaways Table
CREATE TABLE IF NOT EXISTS giveaways (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  deleted_at TIMESTAMPTZ,
  
  -- Creator info
  user_id UUID REFERENCES users(id) ON DELETE CASCADE NOT NULL,
  
  -- Giveaway details
  title TEXT NOT NULL,
  slug TEXT NOT NULL,
  description TEXT,
  thumbnail_url TEXT,
  
  -- Duration & status
  start_date TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  end_date TIMESTAMPTZ NOT NULL,
  status TEXT DEFAULT 'active' NOT NULL,
  
  -- Winner info
  winner_id UUID REFERENCES users(id) ON DELETE SET NULL,
  winner_guest_id UUID,
  winner_selected_at TIMESTAMPTZ,
  
  -- Settings
  max_participants INTEGER,
  allow_guests BOOLEAN DEFAULT TRUE NOT NULL,
  require_email BOOLEAN DEFAULT FALSE NOT NULL,
  
  -- Moderation
  is_featured BOOLEAN DEFAULT FALSE NOT NULL,
  is_banned BOOLEAN DEFAULT FALSE NOT NULL,
  banned_until TIMESTAMPTZ,
  
  -- Constraints
  UNIQUE(user_id, slug),
  CHECK (end_date > start_date),
  CHECK (status IN ('active', 'ended', 'cancelled'))
);

COMMENT ON COLUMN giveaways.updated_at IS 'on_updated_at';
COMMENT ON COLUMN giveaways.status IS 'active, ended, cancelled';

-- Indexes
CREATE INDEX IF NOT EXISTS giveaways_user_id_idx ON giveaways(user_id);
CREATE INDEX IF NOT EXISTS giveaways_status_end_date_idx ON giveaways(status, end_date);
CREATE INDEX IF NOT EXISTS giveaways_slug_idx ON giveaways(slug);

-- RLS Policies
ALTER TABLE giveaways ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Public can view active giveaways" ON giveaways;
CREATE POLICY "Public can view active giveaways"
ON giveaways FOR SELECT
TO authenticated, anon
USING (status = 'active' AND is_banned = FALSE AND deleted_at IS NULL);

DROP POLICY IF EXISTS "User can insert their own giveaways" ON giveaways;
CREATE POLICY "User can insert their own giveaways"
ON giveaways FOR INSERT
TO authenticated
WITH CHECK (
  (SELECT auth.uid()) = user_id
  AND (SELECT role FROM users WHERE id = auth.uid()) IN ('user', 'admin', 'superadmin')
);

DROP POLICY IF EXISTS "User can update their own giveaways" ON giveaways;
CREATE POLICY "User can update their own giveaways"
ON giveaways FOR UPDATE
TO authenticated
USING ((SELECT auth.uid()) = user_id);

DROP POLICY IF EXISTS "Admin can manage all giveaways" ON giveaways;
CREATE POLICY "Admin can manage all giveaways"
ON giveaways FOR ALL
TO authenticated
USING ((SELECT role FROM users WHERE id = auth.uid()) IN ('admin', 'superadmin'));

-- Trigger for updated_at
CREATE TRIGGER on_updated_at BEFORE UPDATE ON giveaways
  FOR EACH ROW EXECUTE PROCEDURE moddatetime (updated_at);

----------------------------------------------------------------

-- 2. Giveaway Participants Table
CREATE TABLE IF NOT EXISTS giveaway_participants (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  
  -- Giveaway reference
  giveaway_id BIGINT REFERENCES giveaways(id) ON DELETE CASCADE NOT NULL,
  
  -- Participant info
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  guest_id UUID,
  
  -- Guest details
  guest_email TEXT,
  guest_name TEXT,
  
  -- Tracking
  ip_address INET NOT NULL,
  user_agent TEXT,
  fingerprint TEXT,
  
  -- Weight for random selection
  weight INTEGER DEFAULT 1 NOT NULL,
  
  -- Prevent duplicates
  UNIQUE(giveaway_id, user_id),
  UNIQUE(giveaway_id, guest_id),
  CHECK (
    (user_id IS NOT NULL AND guest_id IS NULL) OR
    (user_id IS NULL AND guest_id IS NOT NULL)
  )
);

-- Indexes
CREATE INDEX IF NOT EXISTS giveaway_participants_giveaway_id_idx ON giveaway_participants(giveaway_id);
CREATE INDEX IF NOT EXISTS giveaway_participants_user_id_idx ON giveaway_participants(user_id);
CREATE INDEX IF NOT EXISTS giveaway_participants_ip_address_idx ON giveaway_participants(ip_address);
CREATE INDEX IF NOT EXISTS giveaway_participants_created_at_idx ON giveaway_participants(created_at);

-- RLS Policies
ALTER TABLE giveaway_participants ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Public can view participants" ON giveaway_participants;
CREATE POLICY "Public can view participants"
ON giveaway_participants FOR SELECT
TO authenticated, anon
USING (TRUE);

DROP POLICY IF EXISTS "Anyone can insert participation" ON giveaway_participants;
CREATE POLICY "Anyone can insert participation"
ON giveaway_participants FOR INSERT
TO authenticated, anon
WITH CHECK (TRUE);

----------------------------------------------------------------

-- 3. Rate Limiting Table
CREATE TABLE IF NOT EXISTS rate_limits (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  
  -- Identifier
  identifier TEXT NOT NULL,
  action TEXT NOT NULL,
  
  -- Rate limit tracking
  attempts INTEGER DEFAULT 1 NOT NULL,
  window_start TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  
  -- Blocking
  is_blocked BOOLEAN DEFAULT FALSE NOT NULL,
  blocked_until TIMESTAMPTZ,
  
  UNIQUE(identifier, action)
);

-- Indexes
CREATE INDEX IF NOT EXISTS rate_limits_identifier_action_idx ON rate_limits(identifier, action);
CREATE INDEX IF NOT EXISTS rate_limits_window_start_idx ON rate_limits(window_start);
CREATE INDEX IF NOT EXISTS rate_limits_cleanup_idx ON rate_limits(created_at) 
WHERE created_at < NOW() - INTERVAL '24 hours';

----------------------------------------------------------------

-- 4. Abuse Reports Table
CREATE TABLE IF NOT EXISTS abuse_reports (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  
  -- What was reported
  resource_type TEXT NOT NULL,
  resource_id BIGINT NOT NULL,
  
  -- Who reported
  reporter_user_id UUID REFERENCES users(id) ON DELETE SET NULL,
  reporter_ip INET,
  
  -- Report details
  reason TEXT NOT NULL,
  description TEXT,
  
  -- Status
  status TEXT DEFAULT 'pending' NOT NULL,
  reviewed_by UUID REFERENCES users(id) ON DELETE SET NULL,
  reviewed_at TIMESTAMPTZ,
  
  CHECK (status IN ('pending', 'reviewed', 'actioned', 'dismissed'))
);

-- Indexes
CREATE INDEX IF NOT EXISTS abuse_reports_resource_idx ON abuse_reports(resource_type, resource_id);
CREATE INDEX IF NOT EXISTS abuse_reports_status_idx ON abuse_reports(status);

----------------------------------------------------------------
--                                                            --
--                    GIVEAWAY FUNCTIONS                      --
--                                                            --
----------------------------------------------------------------

-- 1. Rate Limiting Function
CREATE OR REPLACE FUNCTION check_rate_limit(
  p_identifier TEXT,
  p_action TEXT,
  p_max_attempts INTEGER DEFAULT 10,
  p_window_minutes INTEGER DEFAULT 60
)
RETURNS BOOLEAN
SECURITY DEFINER SET search_path = public
AS $
DECLARE
  v_record RECORD;
  v_window_start TIMESTAMPTZ;
BEGIN
  v_window_start := NOW() - (p_window_minutes || ' minutes')::INTERVAL;
  
  -- Get or create rate limit record
  SELECT * INTO v_record
  FROM rate_limits
  WHERE identifier = p_identifier AND action = p_action
  FOR UPDATE;
  
  -- Check if blocked
  IF v_record.is_blocked AND v_record.blocked_until > NOW() THEN
    RETURN FALSE;
  END IF;
  
  -- Reset if outside window
  IF v_record.window_start < v_window_start THEN
    UPDATE rate_limits
    SET attempts = 1, window_start = NOW(), is_blocked = FALSE, blocked_until = NULL
    WHERE identifier = p_identifier AND action = p_action;
    RETURN TRUE;
  END IF;
  
  -- Increment attempts
  IF v_record.attempts >= p_max_attempts THEN
    UPDATE rate_limits
    SET is_blocked = TRUE, blocked_until = NOW() + INTERVAL '1 hour'
    WHERE identifier = p_identifier AND action = p_action;
    RETURN FALSE;
  END IF;
  
  UPDATE rate_limits
  SET attempts = attempts + 1
  WHERE identifier = p_identifier AND action = p_action;
  
  RETURN TRUE;
  
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    -- Create new record
    INSERT INTO rate_limits (identifier, action, attempts, window_start)
    VALUES (p_identifier, p_action, 1, NOW());
    RETURN TRUE;
END;
$ LANGUAGE plpgsql;

----------------------------------------------------------------

-- 2. Join Giveaway Function
CREATE OR REPLACE FUNCTION join_giveaway(
  p_giveaway_id BIGINT,
  p_user_id UUID DEFAULT NULL,
  p_guest_id UUID DEFAULT NULL,
  p_guest_email TEXT DEFAULT NULL,
  p_guest_name TEXT DEFAULT NULL,
  p_ip_address INET,
  p_user_agent TEXT DEFAULT NULL,
  p_fingerprint TEXT DEFAULT NULL
)
RETURNS JSON
SECURITY DEFINER SET search_path = public
AS $
DECLARE
  v_giveaway RECORD;
  v_identifier TEXT;
  v_weight INTEGER;
  v_participant_count INTEGER;
  v_ip_count INTEGER;
BEGIN
  -- Get giveaway details
  SELECT * INTO v_giveaway
  FROM giveaways
  WHERE id = p_giveaway_id
  AND deleted_at IS NULL
  FOR UPDATE;
  
  -- Validation checks
  IF NOT FOUND THEN
    RETURN json_build_object('success', FALSE, 'error', 'Giveaway not found');
  END IF;
  
  IF v_giveaway.status != 'active' THEN
    RETURN json_build_object('success', FALSE, 'error', 'Giveaway is not active');
  END IF;
  
  IF v_giveaway.end_date < NOW() THEN
    RETURN json_build_object('success', FALSE, 'error', 'Giveaway has ended');
  END IF;
  
  IF NOT v_giveaway.allow_guests AND p_user_id IS NULL THEN
    RETURN json_build_object('success', FALSE, 'error', 'Guests are not allowed');
  END IF;
  
  -- Check max participants
  IF v_giveaway.max_participants IS NOT NULL THEN
    SELECT COUNT(*) INTO v_participant_count
    FROM giveaway_participants
    WHERE giveaway_id = p_giveaway_id;
    
    IF v_participant_count >= v_giveaway.max_participants THEN
      RETURN json_build_object('success', FALSE, 'error', 'Giveaway is full');
    END IF;
  END IF;
  
  -- Rate limiting
  v_identifier := COALESCE(p_user_id::TEXT, p_ip_address::TEXT);
  IF NOT check_rate_limit(v_identifier, 'giveaway_join', 20, 60) THEN
    RETURN json_build_object('success', FALSE, 'error', 'Too many attempts. Please try again later.');
  END IF;
  
  -- Check IP abuse (max 5 entries per IP per giveaway)
  SELECT COUNT(*) INTO v_ip_count
  FROM giveaway_participants
  WHERE giveaway_id = p_giveaway_id AND ip_address = p_ip_address;
  
  IF v_ip_count >= 5 THEN
    RETURN json_build_object('success', FALSE, 'error', 'Maximum entries reached from this IP');
  END IF;
  
  -- Determine weight
  IF p_user_id IS NOT NULL THEN
    SELECT CASE 
      WHEN plan = 'premium' THEN 3
      ELSE 2
    END INTO v_weight
    FROM users WHERE id = p_user_id;
  ELSE
    v_weight := 1;
  END IF;
  
  -- Insert participant
  INSERT INTO giveaway_participants (
    giveaway_id, user_id, guest_id, guest_email, guest_name,
    ip_address, user_agent, fingerprint, weight
  ) VALUES (
    p_giveaway_id, p_user_id, p_guest_id, p_guest_email, p_guest_name,
    p_ip_address, p_user_agent, p_fingerprint, v_weight
  );
  
  RETURN json_build_object('success', TRUE, 'weight', v_weight);
  
EXCEPTION
  WHEN unique_violation THEN
    RETURN json_build_object('success', FALSE, 'error', 'Already participated');
  WHEN OTHERS THEN
    RETURN json_build_object('success', FALSE, 'error', 'An error occurred');
END;
$ LANGUAGE plpgsql;

----------------------------------------------------------------

-- 3. Select Winner Function
CREATE OR REPLACE FUNCTION select_giveaway_winner(p_giveaway_id BIGINT)
RETURNS JSON
SECURITY DEFINER SET search_path = public
AS $
DECLARE
  v_giveaway RECORD;
  v_winner RECORD;
  v_total_weight BIGINT;
  v_random_weight BIGINT;
  v_cumulative_weight BIGINT := 0;
BEGIN
  -- Get giveaway
  SELECT * INTO v_giveaway
  FROM giveaways
  WHERE id = p_giveaway_id
  FOR UPDATE;
  
  IF NOT FOUND THEN
    RETURN json_build_object('success', FALSE, 'error', 'Giveaway not found');
  END IF;
  
  IF v_giveaway.winner_id IS NOT NULL OR v_giveaway.winner_guest_id IS NOT NULL THEN
    RETURN json_build_object('success', FALSE, 'error', 'Winner already selected');
  END IF;
  
  -- Calculate total weight
  SELECT SUM(weight) INTO v_total_weight
  FROM giveaway_participants
  WHERE giveaway_id = p_giveaway_id;
  
  IF v_total_weight IS NULL OR v_total_weight = 0 THEN
    RETURN json_build_object('success', FALSE, 'error', 'No participants');
  END IF;
  
  -- Generate random number
  v_random_weight := floor(random() * v_total_weight) + 1;
  
  -- Select winner using weighted random
  FOR v_winner IN
    SELECT *, weight
    FROM giveaway_participants
    WHERE giveaway_id = p_giveaway_id
    ORDER BY id
  LOOP
    v_cumulative_weight := v_cumulative_weight + v_winner.weight;
    
    IF v_cumulative_weight >= v_random_weight THEN
      -- Update giveaway with winner
      UPDATE giveaways
      SET 
        winner_id = v_winner.user_id,
        winner_guest_id = v_winner.guest_id,
        winner_selected_at = NOW(),
        status = 'ended'
      WHERE id = p_giveaway_id;
      
      RETURN json_build_object(
        'success', TRUE,
        'winner_id', v_winner.user_id,
        'winner_guest_id', v_winner.guest_id,
        'winner_email', v_winner.guest_email,
        'winner_name', v_winner.guest_name
      );
    END IF;
  END LOOP;
  
  RETURN json_build_object('success', FALSE, 'error', 'Failed to select winner');
END;
$ LANGUAGE plpgsql;

----------------------------------------------------------------

-- 4. Auto-End Expired Giveaways
CREATE OR REPLACE FUNCTION auto_end_expired_giveaways()
RETURNS VOID
SECURITY DEFINER SET search_path = public
AS $
BEGIN
  UPDATE giveaways
  SET status = 'ended'
  WHERE status = 'active'
  AND end_date < NOW()
  AND deleted_at IS NULL;
END;
$ LANGUAGE plpgsql;

----------------------------------------------------------------

-- 5. Cleanup Rate Limits
CREATE OR REPLACE FUNCTION cleanup_old_rate_limits()
RETURNS VOID
SECURITY DEFINER SET search_path = public
AS $
BEGIN
  DELETE FROM rate_limits
  WHERE created_at < NOW() - INTERVAL '24 hours'
  AND is_blocked = FALSE;
  
  -- Unblock expired blocks
  UPDATE rate_limits
  SET is_blocked = FALSE, blocked_until = NULL
  WHERE is_blocked = TRUE
  AND blocked_until < NOW();
END;
$ LANGUAGE plpgsql;
