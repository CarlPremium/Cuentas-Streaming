----------------------------------------------------------------
--                                                            --
--                    STORE SYSTEM                            --
--                                                            --
----------------------------------------------------------------

-- 1. PRODUCTS TABLE
CREATE TABLE IF NOT EXISTS products (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  deleted_at TIMESTAMPTZ,
  
  -- Basic Info
  name TEXT NOT NULL,
  slug TEXT NOT NULL UNIQUE,
  description TEXT,
  
  -- Pricing
  price DECIMAL(10, 2) NOT NULL CHECK (price >= 0),
  original_price DECIMAL(10, 2) CHECK (original_price >= price),
  currency TEXT DEFAULT 'USD' NOT NULL,
  
  -- Media
  image_url TEXT,
  thumbnail_url TEXT,
  
  -- Categorization
  category TEXT NOT NULL,
  duration TEXT, -- e.g., "1 Mes", "3 Meses", "Lifetime"
  
  -- Features (JSON array)
  features JSONB DEFAULT '[]'::jsonb,
  
  -- Status
  is_active BOOLEAN DEFAULT TRUE NOT NULL,
  is_featured BOOLEAN DEFAULT FALSE NOT NULL,
  is_popular BOOLEAN DEFAULT FALSE NOT NULL,
  
  -- Stock Management
  stock_quantity INTEGER,
  unlimited_stock BOOLEAN DEFAULT TRUE NOT NULL,
  
  -- SEO
  meta_title TEXT,
  meta_description TEXT,
  keywords TEXT[],
  
  -- Ordering
  sort_order INTEGER DEFAULT 0 NOT NULL,
  
  -- Admin
  user_id UUID REFERENCES users(id) ON DELETE SET NULL,
  
  -- Constraints
  CONSTRAINT valid_prices CHECK (original_price IS NULL OR original_price > price)
);

-- Indexes for products
CREATE INDEX IF NOT EXISTS products_slug_idx ON products(slug) WHERE deleted_at IS NULL;
CREATE INDEX IF NOT EXISTS products_category_idx ON products(category) WHERE deleted_at IS NULL AND is_active = TRUE;
CREATE INDEX IF NOT EXISTS products_featured_idx ON products(is_featured, sort_order) WHERE deleted_at IS NULL AND is_active = TRUE;
CREATE INDEX IF NOT EXISTS products_active_idx ON products(is_active) WHERE deleted_at IS NULL;
CREATE INDEX IF NOT EXISTS products_created_idx ON products(created_at DESC) WHERE deleted_at IS NULL;

-- 2. PRODUCT CATEGORIES TABLE
CREATE TABLE IF NOT EXISTS product_categories (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  
  name TEXT NOT NULL UNIQUE,
  slug TEXT NOT NULL UNIQUE,
  description TEXT,
  icon TEXT, -- Lucide icon name
  color TEXT, -- Hex color for UI
  sort_order INTEGER DEFAULT 0 NOT NULL,
  is_active BOOLEAN DEFAULT TRUE NOT NULL
);

-- Insert default categories
INSERT INTO product_categories (name, slug, description, icon, color, sort_order) VALUES
  ('Streaming', 'streaming', 'Servicios de streaming de video', 'Tv', '#8B5CF6', 1),
  ('Música', 'musica', 'Plataformas de música y audio', 'Music', '#06B6D4', 2),
  ('Gaming', 'gaming', 'Servicios de videojuegos', 'Gamepad2', '#10B981', 3),
  ('Productividad', 'productividad', 'Herramientas de productividad', 'Briefcase', '#F59E0B', 4),
  ('Educación', 'educacion', 'Plataformas educativas', 'GraduationCap', '#EC4899', 5)
ON CONFLICT (slug) DO NOTHING;

-- 3. ORDERS TABLE
CREATE TABLE IF NOT EXISTS orders (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  
  -- Order Info
  order_number TEXT NOT NULL UNIQUE,
  
  -- Customer
  customer_email TEXT NOT NULL,
  customer_name TEXT,
  customer_telegram TEXT,
  
  -- Product
  product_id BIGINT REFERENCES products(id) ON DELETE SET NULL,
  product_name TEXT NOT NULL, -- Snapshot
  product_price DECIMAL(10, 2) NOT NULL,
  
  -- Payment
  payment_method TEXT NOT NULL, -- 'binance', 'paypal', 'other'
  payment_status TEXT DEFAULT 'pending' NOT NULL, -- 'pending', 'completed', 'failed', 'refunded'
  payment_id TEXT, -- External payment ID
  
  -- Status
  status TEXT DEFAULT 'pending' NOT NULL, -- 'pending', 'processing', 'completed', 'cancelled'
  
  -- Delivery
  delivery_status TEXT DEFAULT 'pending' NOT NULL, -- 'pending', 'delivered', 'failed'
  delivery_notes TEXT,
  delivered_at TIMESTAMPTZ,
  
  -- Admin
  processed_by UUID REFERENCES users(id) ON DELETE SET NULL,
  notes TEXT,
  
  CONSTRAINT valid_payment_status CHECK (payment_status IN ('pending', 'completed', 'failed', 'refunded')),
  CONSTRAINT valid_order_status CHECK (status IN ('pending', 'processing', 'completed', 'cancelled')),
  CONSTRAINT valid_delivery_status CHECK (delivery_status IN ('pending', 'delivered', 'failed'))
);

-- Indexes for orders
CREATE INDEX IF NOT EXISTS orders_number_idx ON orders(order_number);
CREATE INDEX IF NOT EXISTS orders_email_idx ON orders(customer_email);
CREATE INDEX IF NOT EXISTS orders_telegram_idx ON orders(customer_telegram);
CREATE INDEX IF NOT EXISTS orders_status_idx ON orders(status, created_at DESC);
CREATE INDEX IF NOT EXISTS orders_payment_status_idx ON orders(payment_status);
CREATE INDEX IF NOT EXISTS orders_created_idx ON orders(created_at DESC);

-- 4. STORE SETTINGS TABLE
CREATE TABLE IF NOT EXISTS store_settings (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  updated_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  
  -- Telegram
  telegram_handle TEXT NOT NULL,
  telegram_chat_id TEXT,
  
  -- Payment Methods
  binance_enabled BOOLEAN DEFAULT TRUE NOT NULL,
  binance_pay_id TEXT,
  paypal_enabled BOOLEAN DEFAULT TRUE NOT NULL,
  paypal_email TEXT,
  
  -- Store Info
  store_name TEXT DEFAULT 'Tienda' NOT NULL,
  store_description TEXT,
  support_email TEXT,
  
  -- Notifications
  notify_new_orders BOOLEAN DEFAULT TRUE NOT NULL,
  notify_email TEXT,
  
  -- Maintenance
  maintenance_mode BOOLEAN DEFAULT FALSE NOT NULL,
  maintenance_message TEXT
);

-- Insert default settings
INSERT INTO store_settings (telegram_handle, store_name) 
VALUES ('@tu_usuario_telegram', 'Cuentas Premium')
ON CONFLICT DO NOTHING;

----------------------------------------------------------------
--                      FUNCTIONS                             --
----------------------------------------------------------------

-- Function to generate order number
CREATE OR REPLACE FUNCTION generate_order_number()
RETURNS TEXT
LANGUAGE plpgsql
AS $$
DECLARE
  v_number TEXT;
  v_exists BOOLEAN;
BEGIN
  LOOP
    -- Generate format: ORD-YYYYMMDD-XXXX
    v_number := 'ORD-' || TO_CHAR(NOW(), 'YYYYMMDD') || '-' || LPAD(FLOOR(RANDOM() * 10000)::TEXT, 4, '0');

    -- Check if exists
    SELECT EXISTS(SELECT 1 FROM orders WHERE order_number = v_number) INTO v_exists;

    EXIT WHEN NOT v_exists;
  END LOOP;

  RETURN v_number;
END;
$$;

-- Function to create order
CREATE OR REPLACE FUNCTION create_order(
  p_product_id BIGINT,
  p_customer_email TEXT,
  p_customer_name TEXT,
  p_customer_telegram TEXT,
  p_payment_method TEXT
)
RETURNS JSON
SECURITY DEFINER SET search_path = public
AS $$
DECLARE
  v_product RECORD;
  v_order_number TEXT;
  v_order_id BIGINT;
BEGIN
  -- Get product
  SELECT * INTO v_product
  FROM products
  WHERE id = p_product_id
  AND deleted_at IS NULL
  AND is_active = TRUE;

  IF NOT FOUND THEN
    RETURN json_build_object('success', FALSE, 'error', 'Product not found or inactive');
  END IF;

  -- Check stock
  IF NOT v_product.unlimited_stock AND v_product.stock_quantity <= 0 THEN
    RETURN json_build_object('success', FALSE, 'error', 'Product out of stock');
  END IF;

  -- Generate order number
  v_order_number := generate_order_number();

  -- Create order
  INSERT INTO orders (
    order_number,
    customer_email,
    customer_name,
    customer_telegram,
    product_id,
    product_name,
    product_price,
    payment_method,
    status,
    payment_status,
    delivery_status
  ) VALUES (
    v_order_number,
    p_customer_email,
    p_customer_name,
    p_customer_telegram,
    p_product_id,
    v_product.name,
    v_product.price,
    p_payment_method,
    'pending',
    'pending',
    'pending'
  ) RETURNING id INTO v_order_id;

  -- Update stock if not unlimited
  IF NOT v_product.unlimited_stock THEN
    UPDATE products
    SET stock_quantity = stock_quantity - 1
    WHERE id = p_product_id;
  END IF;

  RETURN json_build_object(
    'success', TRUE,
    'order_id', v_order_id,
    'order_number', v_order_number
  );
END;
$$ LANGUAGE plpgsql;

-- Function to update product
CREATE OR REPLACE FUNCTION update_product_timestamp()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;

-- Trigger for products updated_at
CREATE TRIGGER products_updated_at
BEFORE UPDATE ON products
FOR EACH ROW
EXECUTE FUNCTION update_product_timestamp();

-- Trigger for orders updated_at
CREATE TRIGGER orders_updated_at
BEFORE UPDATE ON orders
FOR EACH ROW
EXECUTE FUNCTION update_product_timestamp();

----------------------------------------------------------------
--                      PERMISSIONS                           --
----------------------------------------------------------------

-- Public can read active products
GRANT SELECT ON products TO anon, authenticated;
GRANT SELECT ON product_categories TO anon, authenticated;

-- Authenticated can create orders
GRANT INSERT ON orders TO authenticated;
GRANT SELECT ON orders TO authenticated;

-- Only admins can manage products
-- (Handled by RLS policies)

----------------------------------------------------------------
--                      RLS POLICIES                          --
----------------------------------------------------------------

-- Enable RLS
ALTER TABLE products ENABLE ROW LEVEL SECURITY;
ALTER TABLE product_categories ENABLE ROW LEVEL SECURITY;
ALTER TABLE orders ENABLE ROW LEVEL SECURITY;
ALTER TABLE store_settings ENABLE ROW LEVEL SECURITY;

-- Products: Public can view active products
CREATE POLICY "Public can view active products"
ON products FOR SELECT
TO anon, authenticated
USING (deleted_at IS NULL AND is_active = TRUE);

-- Products: Admins can do everything
CREATE POLICY "Admins can manage products"
ON products FOR ALL
TO authenticated
USING (
  EXISTS (
    SELECT 1 FROM users
    WHERE users.id = auth.uid()
    AND users.role IN ('admin', 'superadmin')
  )
);

-- Categories: Everyone can view active categories
CREATE POLICY "Everyone can view categories"
ON product_categories FOR SELECT
TO anon, authenticated
USING (is_active = TRUE);

-- Orders: Users can view their own orders
CREATE POLICY "Users can view own orders"
ON orders FOR SELECT
TO authenticated
USING (customer_email = auth.email());

-- Orders: Admins can view all orders
CREATE POLICY "Admins can view all orders"
ON orders FOR SELECT
TO authenticated
USING (
  EXISTS (
    SELECT 1 FROM users
    WHERE users.id = auth.uid()
    AND users.role IN ('admin', 'superadmin')
  )
);

-- Orders: Admins can update orders
CREATE POLICY "Admins can update orders"
ON orders FOR UPDATE
TO authenticated
USING (
  EXISTS (
    SELECT 1 FROM users
    WHERE users.id = auth.uid()
    AND users.role IN ('admin', 'superadmin')
  )
);

-- Store Settings: Only admins can access
CREATE POLICY "Admins can manage store settings"
ON store_settings FOR ALL
TO authenticated
USING (
  EXISTS (
    SELECT 1 FROM users
    WHERE users.id = auth.uid()
    AND users.role IN ('admin', 'superadmin')
  )
);

----------------------------------------------------------------
--                      GRANTS                                --
----------------------------------------------------------------

GRANT EXECUTE ON FUNCTION generate_order_number TO authenticated;
GRANT EXECUTE ON FUNCTION create_order TO authenticated, anon;

COMMENT ON TABLE products IS 'Store products/offerings';
COMMENT ON TABLE product_categories IS 'Product categories for organization';
COMMENT ON TABLE orders IS 'Customer orders';
COMMENT ON TABLE store_settings IS 'Store configuration and settings';
